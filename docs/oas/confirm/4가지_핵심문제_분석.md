# 4가지 핵심 문제 상세 분석 (업데이트: 2025-01-29)

> **상태**: 주요 문제점들이 현재 OAS 클라이언트 구조 분석을 통해 대부분 해소됨
> **결론**: 복잡한 아키텍처 불필요, 간단한 래핑 방식으로 충분

## 문제 1: TanStack Query 통합 접근법

### 🎯 문제 정의
**"Query Manager 클래스 방식 vs 컴포지션 함수 방식"**

현재 두 가지 접근법이 공존하면서 일관성이 부족한 상황:

#### 현재 상황 분석

**1. 기존 컴포지션 함수 방식 (현재 사용 중)**
```typescript
// apps/web/src/features/mentoring/apis/queries.ts
export const userQueries = {
  list: (params: GetUsersParams) => ({
    queryKey: userKeys.lists().queryKey,
    queryFn: () => userService.getUsers(params),
  }),
  detail: (id: string) => ({
    queryKey: userKeys.detail(id).queryKey,
    queryFn: () => userService.getUserById(id),
  })
}
```

**2. Query Manager 클래스 방식 (이전 계획에서 제안)**
```typescript
// 이전 계획안
class QueryManager {
  constructor(private service: UserService) {}
  
  getListQuery(params: GetUsersParams) {
    return {
      queryKey: ['users', 'list', params],
      queryFn: () => this.service.getUsers(params)
    }
  }
}
```

### 📊 현재 코드 깊이 분석

#### useBaseMutation의 고도화된 기능
```typescript
// apps/web/src/shared/hooks/useBaseMutation.ts
export function useBaseMutation<TData, TError, TVariables, TContext>({
  queryKey,
  successMessage,
  errorMessage,
  onMutate,
  onSuccess,
  onError
}) {
  return useMutation({
    onMutate: async (variables) => {
      // 기존 쿼리 취소
      await queryClient.cancelQueries({ queryKey })
      
      // 이전 데이터 백업
      const previousData = queryClient.getQueryData<TData>(queryKey)
      
      // 낙관적 업데이트 수행
      if (onMutate) {
        const optimisticData = await onMutate(variables)
        if (optimisticData) {
          queryClient.setQueryData(queryKey, optimisticData)
        }
      }
      
      return { previousData }
    },
    
    onError: (err, variables, context) => {
      // 롤백 수행
      if (context?.previousData) {
        queryClient.setQueryData(queryKey, context.previousData)
      }
      
      // 에러 토스트 표시
      if (errorMessage) {
        toast.error(errorMessage)
      }
      
      // 커스텀 에러 핸들러
      onError?.(err, variables, context)
    },
    
    onSuccess: (data, variables, context) => {
      // 성공 토스트 표시
      if (successMessage) {
        toast.success(successMessage)
      }
      
      // 관련 쿼리 무효화
      queryClient.invalidateQueries({ queryKey })
      
      // 커스텀 성공 핸들러
      onSuccess?.(data, variables, context)
    }
  })
}
```

#### Query Key Factory의 고급 패턴
```typescript
// apps/web/src/features/mentoring/apis/queries.ts
export const userKeys = createQueryKeys("users", {
  all: null,
  lists: () => ["list"] as const,
  list: (params: GetUsersParams) => [{ ...params }] as const,
  details: () => ["detail"] as const,  
  detail: (id: string) => [id] as const,
})

// 계층적 무효화 지원
queryClient.invalidateQueries(userKeys.lists()) // 모든 리스트 쿼리 무효화
queryClient.invalidateQueries(userKeys.details()) // 모든 상세 쿼리 무효화
queryClient.invalidateQueries(userKeys.all) // 모든 user 관련 쿼리 무효화
```

### ✅ **문제 해소됨** - UserApiFp 패턴 발견

**현재 OAS 클라이언트 분석 결과:**

1. **UserApiFp** 함수형 패턴이 이미 생성되어 있음
2. **FP 함수들**이 runtime에 axios 인스턴스를 주입받는 구조
3. **기존 TanStack Query 패턴**과 완벽 호환 가능

```typescript
// 현재 생성된 구조 (packages/api-client/src/services/user-api.ts)
export const UserApiFp = {
  getAllUsers(params?: GetUsersParams) {
    return (axios: AxiosInstance): Promise<UserListResponseWrapper> => {
      // 순수한 axios 호출 로직
    }
  }
}
```

### ✅ **간단한 해결책** - 직접 래핑 방식

**기존 아키텍처를 그대로 활용하는 단순한 접근법:**

```typescript
// apps/web/src/shared/api/services/user-api.service.ts
export class UserApiService extends BaseApiService {
  async getAllUsers(params?: GetUsersParams) {
    try {
      // 1. FP 함수에 파라미터 전달
      const getAllUsersFn = UserApiFp.getAllUsers(params)
      
      // 2. 인증된 axios 인스턴스 주입
      const response = await getAllUsersFn(customAxios)
      
      // 3. 기존 형식으로 변환
      return this.handlePaginatedResponse(response.data)
    } catch (error) {
      throw this.handleError(error)
    }
  }
}
```

**장점:**
- 복잡한 Adapter 패턴 불필요
- 기존 BaseApiService 패턴 100% 유지
- 개발자 학습 비용 제로

---

## 문제 2: Auth.js (Next-Auth) 통합

### 🎯 문제 정의
**"생성된 OAS 코드에 Next-Auth 세션 자동 주입"**

생성된 API 클라이언트가 현재 인증 시스템과 분리되어 있는 문제

### 📊 현재 인증 시스템 분석

#### 고도화된 ApiClient 구현
```typescript
// apps/web/src/shared/api/core/axios.ts
class ApiClient {
  private instance: AxiosInstance
  
  constructor() {
    this.instance = axios.create({
      baseURL: process.env.NEXT_PUBLIC_API_URL,
      timeout: 10000,
    })
    
    this.setupInterceptors()
  }
  
  private setupInterceptors() {
    // 요청 인터셉터 - 자동 토큰 주입
    this.instance.interceptors.request.use(
      async (config) => {
        const session = await getSession()
        if (session?.accessToken) {
          config.headers.Authorization = `Bearer ${session.accessToken}`
        }
        return config
      },
      (error) => Promise.reject(error)
    )
    
    // 응답 인터셉터 - 토큰 갱신
    this.instance.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config
        
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true
          
          try {
            // 토큰 갱신 시도
            const session = await getSession()
            if (session) {
              await signIn('refresh-token', { 
                refreshToken: session.refreshToken 
              })
              
              // 새 토큰으로 재시도
              const newSession = await getSession()
              if (newSession?.accessToken) {
                originalRequest.headers.Authorization = `Bearer ${newSession.accessToken}`
                return this.instance(originalRequest)
              }
            }
          } catch (refreshError) {
            // 갱신 실패 시 로그아웃
            await signOut()
            window.location.href = '/login'
          }
        }
        
        return Promise.reject(error)
      }
    )
  }
}
```

#### Next-Auth 구성
```typescript
// apps/web/src/shared/auth/auth.ts
export const authOptions: NextAuthOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    GitHubProvider({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!,
    }),
    // ... 기타 소셜 로그인 프로바이더
  ],
  
  callbacks: {
    async jwt({ token, account, user }) {
      // JWT 토큰 관리 로직
      if (account) {
        token.accessToken = account.access_token
        token.refreshToken = account.refresh_token
      }
      return token
    },
    
    async session({ session, token }) {
      // 세션에 토큰 정보 포함
      session.accessToken = token.accessToken as string
      session.refreshToken = token.refreshToken as string
      return session
    }
  }
}
```

### ✅ **문제 해소됨** - FP 패턴의 축 주입 구조

**현재 구조 분석 결과:**

1. **UserApiFp** 함수들이 runtime에 axios 인스턴스를 받음
2. **기존 customAxios**(인증 인터셉터 포함)를 직접 주입 가능
3. **복잡한 Configuration 매니저 불필요**

```typescript
// 기존 인증된 axios 클래스 (apps/web/src/shared/api/core/axios.ts)
class ApiClient {
  // 토큰 자동 주입, 갱신 로직 포함
}
export const apiClient = new ApiClient()

// FP 함수에 직접 주입
const getAllUsersFn = UserApiFp.getAllUsers(params)
const result = await getAllUsersFn(apiClient.instance) // 인증 자동 처리
```

### ✅ **단순한 해결책** - 직접 주입 방식

**복잡한 Configuration 없이 바로 해결:**

```typescript
// apps/web/src/shared/api/services/user-api.service.ts
import { UserApiFp } from '@repo/api-client'
import { apiClient } from '../core/axios' // 기존 인증 클라이언트

export class UserApiService extends BaseApiService {
  async getAllUsers(params?: GetUsersParams) {
    const fn = UserApiFp.getAllUsers(params)
    const response = await fn(apiClient.instance) // 인증 자동 처리
    return this.transformResponse(response)
  }
}
```

**장점:**
- Configuration 매니저 불필요
- 기존 인증 시스템 100% 재사용
- 코드 복잡성 최소화

---

## 문제 3: 자동 생성 코드 격리

### 🎯 문제 정의
**"생성된 코드의 변경 안전성과 커스터마이징 전략"**

자동 생성되는 코드를 보호하면서도 필요한 커스터마이징을 가능하게 하는 방법

### 📊 현재 생성 코드 구조 분석

#### packages/api-client 구조
```
packages/api-client/
├── src/
│   ├── apis/           # 생성된 API 클래스들
│   ├── models/         # 생성된 타입 정의들
│   ├── configuration.ts # API 설정
│   └── index.ts        # 전체 export
├── package.json
└── README.md
```

#### 생성된 코드 예시
```typescript
// packages/api-client/src/apis/user-api.ts (자동 생성)
/**
 * UserApi - 자동 생성된 코드
 * 이 파일을 직접 수정하지 마세요
 */
export class UserApi extends BaseAPI {
  public getAllUsers(requestParameters: GetAllUsersRequest = {}, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration).getAllUsers(requestParameters, options)(this.axios, this.basePath)
  }
  
  public getUserById(requestParameters: GetUserByIdRequest, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration).getUserById(requestParameters, options)(this.axios, this.basePath)
  }
}
```

### ✅ **문제 해소됨** - 물리적 격리로 자연스럽게 해결

**현재 구조의 장점:**

1. **물리적 격리**: `packages/api-client` vs `apps/web/src/shared/api` 완전 분리
2. **의존성 방향**: 생성 코드 → 비즈니스 코드 (단방향)
3. **커스터마이징**: 래핑 서비스에서 자유롭게 처리
4. **버전 관리**: 생성 코드는 .gitignore 제외 가능

### ✅ **단순한 해결책** - 직접 사용 방식

**불필요한 복잡성 제거:**

```
packages/api-client/     # 생성된 코드 (건드리지 않음)
apps/web/src/shared/api/
├── core/               # 기존 BaseApiService, axios (유지)
└── services/           # 생성된 API를 래핑하는 서비스들
```

**장점:**
- generated/ 폴더 불필요
- adapters/ 레이어 불필요  
- 직관적이고 단순한 구조
- 관리 포인트 최소화

#### 구현 예시
```typescript
// apps/web/src/shared/api/adapters/user-api.adapter.ts
export class UserApiAdapter extends BaseApiService {
  constructor(private generatedApi: UserApi) {
    super('/users')
  }
  
  async getUsers(params: GetUsersParams): Promise<ApiResponse<UserResponseDto[]>> {
    try {
      const response = await this.generatedApi.getAllUsers(params)
      return {
        data: response.data,
        status: response.status,
        message: 'Success'
      }
    } catch (error) {
      return this.handleError(error)
    }
  }
}
```

---

## 문제 4: API 변경 알림 자동화

### 🎯 문제 정의
**"백엔드 API 스펙 변경 시 프론트엔드 팀에 자동 알림"**

OpenAPI 스펙 변경사항을 자동으로 감지하고 관련 팀에게 알림을 보내는 시스템

### 📊 현재 CI/CD 파이프라인 분석

#### 현재 API 클라이언트 생성 과정
```bash
# apps/api/package.json
"scripts": {
  "export:swagger": "ts-node scripts/export-swagger.ts",
  "postbuild": "pnpm export:swagger"
}

# packages/api-client/package.json  
"scripts": {
  "generate": "openapi-generator-cli generate -i ../../../apps/api/swagger-spec.json -g typescript-axios -o src/"
}

# 루트 package.json
"scripts": {
  "gen:api": "cd apps/api && pnpm export:swagger && cd ../../packages/api-client && pnpm generate"
}
```

### 🔄 **현재 시점에서는 선택사항** - 우선순위 조정

**현실적인 접근:**

1. **1차 목표**: 기본 통합 완료 후 고려
2. **현재 우선순위**: 낮음 (Nice to have)
3. **단계적 도입**: 필요성이 커지면 나중에 추가
4. **현재 대안**: 수동 프로세스로도 충분

**당장 불필요한 이유:**
- 팀 규모가 크지 않음
- API 변경 빈도가 높지 않음
- 기본 통합이 더 시급
- 복잡성 대비 효용이 낮음

### 💡 해결 방향

**GitHub Actions 기반 자동화 파이프라인**

#### 1단계: 스펙 변경 감지
```yaml
# .github/workflows/api-spec-monitor.yml
name: API Spec Monitor

on:
  push:
    paths:
      - 'apps/api/src/**/*.ts'
      - 'apps/api/src/**/*.dto.ts'
  
jobs:
  detect-changes:
    runs-on: ubuntu-latest
    steps:
      - name: Generate new spec
        run: |
          cd apps/api
          pnpm export:swagger
          
      - name: Compare specs
        run: |
          # 이전 스펙과 비교하여 변경사항 감지
          npx openapi-diff swagger-spec-old.json swagger-spec.json --format json > changes.json
          
      - name: Analyze impact
        if: ${{ hashFiles('changes.json') != '' }}
        run: |
          # 변경사항이 프론트엔드에 미치는 영향 분석
          node scripts/analyze-api-changes.js
```

#### 2단계: 자동 알림 시스템
```typescript
// scripts/analyze-api-changes.js
interface ApiChange {
  type: 'breaking' | 'non-breaking' | 'addition'
  path: string
  method: string
  description: string
  impact: 'high' | 'medium' | 'low'
}

async function analyzeChanges(changes: any[]): Promise<ApiChange[]> {
  // OpenAPI diff 결과를 분석하여 변경사항 분류
  return changes.map(change => ({
    type: classifyChange(change),
    path: change.path,
    method: change.method,
    description: generateDescription(change),
    impact: assessImpact(change)
  }))
}

async function sendNotifications(changes: ApiChange[]) {
  const breakingChanges = changes.filter(c => c.type === 'breaking')
  
  if (breakingChanges.length > 0) {
    // Slack 알림
    await sendSlackNotification({
      channel: '#frontend-team',
      message: `🚨 Breaking API Changes Detected!\n${formatChanges(breakingChanges)}`
    })
    
    // GitHub Issue 자동 생성
    await createGitHubIssue({
      title: 'API Breaking Changes - Action Required',
      body: generateIssueBody(breakingChanges),
      labels: ['api-change', 'breaking', 'frontend']
    })
  }
}
```

## 📊 문제 해결 현황 (2025-01-29 업데이트)

### ✅ **해결 완료**
1. **TanStack Query 통합** - UserApiFp 패턴으로 완벽 해결
2. **Auth.js 통합** - FP 함수 + customAxios 직접 주입으로 해결
3. **코드 격리** - 물리적 분리로 자연스럽게 해결

### 🔄 **선택사항**
4. **변경 알림 자동화** - 현재 시점에서는 불필요 (나중에 필요시 추가)

### 🎯 **새로운 접근법**

**복잡한 통합 아키텍처 불필요** - 다음과 같은 이유로 간단한 래핑 방식이 최적:

1. **UserApiFp** 패턴이 기존 아키텍처와 완벽 호환
2. **물리적 코드 분리**로 격리 문제 자연 해결
3. **FP + axios 주입**으로 인증 문제 간단 해결
4. **기존 인프라 100% 재사용** 가능

**결론**: 2-3주 내로 간단하고 안전하게 통합 가능