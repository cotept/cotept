/* tslint:disable */
/* eslint-disable */
/**
 * CotePT API
 * 코딩 테스트 멘토링 플랫폼 API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { AvailabilityResponseWrapper } from '../types';
// @ts-ignore
import type { CheckEmailAvailabilityRequestDto } from '../types';
// @ts-ignore
import type { CheckUserIdAvailabilityRequestDto } from '../types';
// @ts-ignore
import type { ConfirmSocialLinkRequestDto } from '../types';
// @ts-ignore
import type { EmailVerificationResultResponseWrapper } from '../types';
// @ts-ignore
import type { ExchangeAuthCodeRequestDto } from '../types';
// @ts-ignore
import type { FindIdRequestDto } from '../types';
// @ts-ignore
import type { FindIdResponseWrapper } from '../types';
// @ts-ignore
import type { GetAllUsers400Response } from '../types';
// @ts-ignore
import type { GetAllUsers401Response } from '../types';
// @ts-ignore
import type { GetAllUsers403Response } from '../types';
// @ts-ignore
import type { GetAllUsers500Response } from '../types';
// @ts-ignore
import type { LoginRequestDto } from '../types';
// @ts-ignore
import type { LogoutResponseWrapper } from '../types';
// @ts-ignore
import type { RefreshTokenRequestDto } from '../types';
// @ts-ignore
import type { ResetPasswordRequestDto } from '../types';
// @ts-ignore
import type { ResetPasswordResponseWrapper } from '../types';
// @ts-ignore
import type { SendVerificationCodeRequestDto } from '../types';
// @ts-ignore
import type { TokenResponseWrapper } from '../types';
// @ts-ignore
import type { ValidateTokenRequestDto } from '../types';
// @ts-ignore
import type { ValidationResultResponseWrapper } from '../types';
// @ts-ignore
import type { VerificationCodeResponseWrapper } from '../types';
// @ts-ignore
import type { VerifyCodeRequestDto } from '../types';
/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 회원가입 시 이메일 주소의 사용 가능 여부를 확인합니다.
         * @summary 이메일 중복 확인
         * @param {CheckEmailAvailabilityRequestDto} checkEmailAvailabilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEmailAvailability: async (checkEmailAvailabilityRequestDto: CheckEmailAvailabilityRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkEmailAvailabilityRequestDto' is not null or undefined
            assertParamExists('checkEmailAvailability', 'checkEmailAvailabilityRequestDto', checkEmailAvailabilityRequestDto)
            const localVarPath = `/api/v1/auth/check-email-availability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkEmailAvailabilityRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 회원가입 시 사용자 ID의 사용 가능 여부를 확인합니다.
         * @summary 사용자 ID 중복 확인
         * @param {CheckUserIdAvailabilityRequestDto} checkUserIdAvailabilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserIdAvailability: async (checkUserIdAvailabilityRequestDto: CheckUserIdAvailabilityRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkUserIdAvailabilityRequestDto' is not null or undefined
            assertParamExists('checkUserIdAvailability', 'checkUserIdAvailabilityRequestDto', checkUserIdAvailabilityRequestDto)
            const localVarPath = `/api/v1/auth/check-userid-availability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkUserIdAvailabilityRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 기존 계정에 소셜 계정 연결을 승인 또는 거부합니다.
         * @summary 소셜 계정 연결 확인
         * @param {ConfirmSocialLinkRequestDto} confirmSocialLinkRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSocialLink: async (confirmSocialLinkRequestDto: ConfirmSocialLinkRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmSocialLinkRequestDto' is not null or undefined
            assertParamExists('confirmSocialLink', 'confirmSocialLinkRequestDto', confirmSocialLinkRequestDto)
            const localVarPath = `/api/v1/auth/confirm-social-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmSocialLinkRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 소셜 로그인 후 서버에서 발급된 임시 인증 코드를 토큰으로 교환합니다.
         * @summary 임시 인증 코드를 실제 토큰으로 교환
         * @param {ExchangeAuthCodeRequestDto} exchangeAuthCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeAuthCode: async (exchangeAuthCodeRequestDto: ExchangeAuthCodeRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exchangeAuthCodeRequestDto' is not null or undefined
            assertParamExists('exchangeAuthCode', 'exchangeAuthCodeRequestDto', exchangeAuthCodeRequestDto)
            const localVarPath = `/api/v1/auth/exchange-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exchangeAuthCodeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 인증된 이메일 또는 전화번호를 통해 사용자 아이디(이메일)를 찾습니다. 먼저 send-verification-code 호출 후 인증 코드를 발급받아야 합니다.
         * @summary 아이디 찾기
         * @param {FindIdRequestDto} findIdRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findId: async (findIdRequestDto: FindIdRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findIdRequestDto' is not null or undefined
            assertParamExists('findId', 'findIdRequestDto', findIdRequestDto)
            const localVarPath = `/api/v1/auth/find-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findIdRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일과 비밀번호로 로그인하고 토큰을 발급합니다.
         * @summary 로그인
         * @param {LoginRequestDto} loginRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequestDto: LoginRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequestDto' is not null or undefined
            assertParamExists('login', 'loginRequestDto', loginRequestDto)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자를 로그아웃하고 토큰을 무효화합니다.
         * @summary 로그아웃
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 리프레시 토큰을 사용하여 새로운 액세스 토큰을 발급합니다.
         * @summary 토큰 갱신
         * @param {RefreshTokenRequestDto} refreshTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenRequestDto: RefreshTokenRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequestDto' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenRequestDto', refreshTokenRequestDto)
            const localVarPath = `/api/v1/auth/silent-refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 인증된 사용자의 비밀번호를 재설정합니다. 먼저 send-verification-code 호출 후 인증 코드를 발급받아야 합니다.
         * @summary 비밀번호 재설정
         * @param {ResetPasswordRequestDto} resetPasswordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRequestDto: ResetPasswordRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequestDto' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequestDto', resetPasswordRequestDto)
            const localVarPath = `/api/v1/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 멘토 사용자가 사용할 프로필(mentee/mentor)을 선택합니다. activeProfile 메타데이터가 포함된 새로운 Access Token을 발급받습니다.
         * @summary 프로필 선택
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectProfile: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('selectProfile', 'body', body)
            const localVarPath = `/api/v1/auth/select-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일 또는 전화번호로 인증 코드를 발송합니다. 아이디 찾기나 비밀번호 재설정을 위해 사용됩니다.
         * @summary 인증 코드 발송
         * @param {SendVerificationCodeRequestDto} sendVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerificationCode: async (sendVerificationCodeRequestDto: SendVerificationCodeRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendVerificationCodeRequestDto' is not null or undefined
            assertParamExists('sendVerificationCode', 'sendVerificationCodeRequestDto', sendVerificationCodeRequestDto)
            const localVarPath = `/api/v1/auth/send-verification-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendVerificationCodeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 액세스 토큰의 유효성을 검증합니다.
         * @summary 토큰 검증
         * @param {ValidateTokenRequestDto} validateTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken: async (validateTokenRequestDto: ValidateTokenRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateTokenRequestDto' is not null or undefined
            assertParamExists('validateToken', 'validateTokenRequestDto', validateTokenRequestDto)
            const localVarPath = `/api/v1/auth/validate-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateTokenRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 발송된 인증 코드의 유효성을 검증합니다. 이 과정을 통해 인증을 완료할 수 있습니다.
         * @summary 인증 코드 확인
         * @param {VerifyCodeRequestDto} verifyCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCode: async (verifyCodeRequestDto: VerifyCodeRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyCodeRequestDto' is not null or undefined
            assertParamExists('verifyCode', 'verifyCodeRequestDto', verifyCodeRequestDto)
            const localVarPath = `/api/v1/auth/verify-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyCodeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 회원가입 시 이메일 주소의 사용 가능 여부를 확인합니다.
         * @summary 이메일 중복 확인
         * @param {CheckEmailAvailabilityRequestDto} checkEmailAvailabilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkEmailAvailability(checkEmailAvailabilityRequestDto: CheckEmailAvailabilityRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailabilityResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkEmailAvailability(checkEmailAvailabilityRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.checkEmailAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 회원가입 시 사용자 ID의 사용 가능 여부를 확인합니다.
         * @summary 사용자 ID 중복 확인
         * @param {CheckUserIdAvailabilityRequestDto} checkUserIdAvailabilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserIdAvailability(checkUserIdAvailabilityRequestDto: CheckUserIdAvailabilityRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailabilityResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserIdAvailability(checkUserIdAvailabilityRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.checkUserIdAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 기존 계정에 소셜 계정 연결을 승인 또는 거부합니다.
         * @summary 소셜 계정 연결 확인
         * @param {ConfirmSocialLinkRequestDto} confirmSocialLinkRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmSocialLink(confirmSocialLinkRequestDto: ConfirmSocialLinkRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmSocialLink(confirmSocialLinkRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.confirmSocialLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 소셜 로그인 후 서버에서 발급된 임시 인증 코드를 토큰으로 교환합니다.
         * @summary 임시 인증 코드를 실제 토큰으로 교환
         * @param {ExchangeAuthCodeRequestDto} exchangeAuthCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exchangeAuthCode(exchangeAuthCodeRequestDto: ExchangeAuthCodeRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exchangeAuthCode(exchangeAuthCodeRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.exchangeAuthCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 인증된 이메일 또는 전화번호를 통해 사용자 아이디(이메일)를 찾습니다. 먼저 send-verification-code 호출 후 인증 코드를 발급받아야 합니다.
         * @summary 아이디 찾기
         * @param {FindIdRequestDto} findIdRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findId(findIdRequestDto: FindIdRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindIdResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findId(findIdRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.findId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일과 비밀번호로 로그인하고 토큰을 발급합니다.
         * @summary 로그인
         * @param {LoginRequestDto} loginRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequestDto: LoginRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자를 로그아웃하고 토큰을 무효화합니다.
         * @summary 로그아웃
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 리프레시 토큰을 사용하여 새로운 액세스 토큰을 발급합니다.
         * @summary 토큰 갱신
         * @param {RefreshTokenRequestDto} refreshTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenRequestDto: RefreshTokenRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 인증된 사용자의 비밀번호를 재설정합니다. 먼저 send-verification-code 호출 후 인증 코드를 발급받아야 합니다.
         * @summary 비밀번호 재설정
         * @param {ResetPasswordRequestDto} resetPasswordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRequestDto: ResetPasswordRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetPasswordResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 멘토 사용자가 사용할 프로필(mentee/mentor)을 선택합니다. activeProfile 메타데이터가 포함된 새로운 Access Token을 발급받습니다.
         * @summary 프로필 선택
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async selectProfile(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.selectProfile(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.selectProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일 또는 전화번호로 인증 코드를 발송합니다. 아이디 찾기나 비밀번호 재설정을 위해 사용됩니다.
         * @summary 인증 코드 발송
         * @param {SendVerificationCodeRequestDto} sendVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendVerificationCode(sendVerificationCodeRequestDto: SendVerificationCodeRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationCodeResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendVerificationCode(sendVerificationCodeRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.sendVerificationCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 액세스 토큰의 유효성을 검증합니다.
         * @summary 토큰 검증
         * @param {ValidateTokenRequestDto} validateTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateToken(validateTokenRequestDto: ValidateTokenRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationResultResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateToken(validateTokenRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.validateToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 발송된 인증 코드의 유효성을 검증합니다. 이 과정을 통해 인증을 완료할 수 있습니다.
         * @summary 인증 코드 확인
         * @param {VerifyCodeRequestDto} verifyCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyCode(verifyCodeRequestDto: VerifyCodeRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailVerificationResultResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyCode(verifyCodeRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.verifyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 회원가입 시 이메일 주소의 사용 가능 여부를 확인합니다.
         * @summary 이메일 중복 확인
         * @param {AuthApiCheckEmailAvailabilityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEmailAvailability(requestParameters: AuthApiCheckEmailAvailabilityRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailabilityResponseWrapper> {
            return localVarFp.checkEmailAvailability(requestParameters.checkEmailAvailabilityRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 회원가입 시 사용자 ID의 사용 가능 여부를 확인합니다.
         * @summary 사용자 ID 중복 확인
         * @param {AuthApiCheckUserIdAvailabilityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserIdAvailability(requestParameters: AuthApiCheckUserIdAvailabilityRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailabilityResponseWrapper> {
            return localVarFp.checkUserIdAvailability(requestParameters.checkUserIdAvailabilityRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 기존 계정에 소셜 계정 연결을 승인 또는 거부합니다.
         * @summary 소셜 계정 연결 확인
         * @param {AuthApiConfirmSocialLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSocialLink(requestParameters: AuthApiConfirmSocialLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseWrapper> {
            return localVarFp.confirmSocialLink(requestParameters.confirmSocialLinkRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 소셜 로그인 후 서버에서 발급된 임시 인증 코드를 토큰으로 교환합니다.
         * @summary 임시 인증 코드를 실제 토큰으로 교환
         * @param {AuthApiExchangeAuthCodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeAuthCode(requestParameters: AuthApiExchangeAuthCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseWrapper> {
            return localVarFp.exchangeAuthCode(requestParameters.exchangeAuthCodeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 인증된 이메일 또는 전화번호를 통해 사용자 아이디(이메일)를 찾습니다. 먼저 send-verification-code 호출 후 인증 코드를 발급받아야 합니다.
         * @summary 아이디 찾기
         * @param {AuthApiFindIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findId(requestParameters: AuthApiFindIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<FindIdResponseWrapper> {
            return localVarFp.findId(requestParameters.findIdRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일과 비밀번호로 로그인하고 토큰을 발급합니다.
         * @summary 로그인
         * @param {AuthApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters: AuthApiLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseWrapper> {
            return localVarFp.login(requestParameters.loginRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자를 로그아웃하고 토큰을 무효화합니다.
         * @summary 로그아웃
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<LogoutResponseWrapper> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 리프레시 토큰을 사용하여 새로운 액세스 토큰을 발급합니다.
         * @summary 토큰 갱신
         * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(requestParameters: AuthApiRefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseWrapper> {
            return localVarFp.refreshToken(requestParameters.refreshTokenRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 인증된 사용자의 비밀번호를 재설정합니다. 먼저 send-verification-code 호출 후 인증 코드를 발급받아야 합니다.
         * @summary 비밀번호 재설정
         * @param {AuthApiResetPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(requestParameters: AuthApiResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResetPasswordResponseWrapper> {
            return localVarFp.resetPassword(requestParameters.resetPasswordRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 멘토 사용자가 사용할 프로필(mentee/mentor)을 선택합니다. activeProfile 메타데이터가 포함된 새로운 Access Token을 발급받습니다.
         * @summary 프로필 선택
         * @param {AuthApiSelectProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectProfile(requestParameters: AuthApiSelectProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseWrapper> {
            return localVarFp.selectProfile(requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일 또는 전화번호로 인증 코드를 발송합니다. 아이디 찾기나 비밀번호 재설정을 위해 사용됩니다.
         * @summary 인증 코드 발송
         * @param {AuthApiSendVerificationCodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerificationCode(requestParameters: AuthApiSendVerificationCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<VerificationCodeResponseWrapper> {
            return localVarFp.sendVerificationCode(requestParameters.sendVerificationCodeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 액세스 토큰의 유효성을 검증합니다.
         * @summary 토큰 검증
         * @param {AuthApiValidateTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken(requestParameters: AuthApiValidateTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ValidationResultResponseWrapper> {
            return localVarFp.validateToken(requestParameters.validateTokenRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 발송된 인증 코드의 유효성을 검증합니다. 이 과정을 통해 인증을 완료할 수 있습니다.
         * @summary 인증 코드 확인
         * @param {AuthApiVerifyCodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCode(requestParameters: AuthApiVerifyCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<EmailVerificationResultResponseWrapper> {
            return localVarFp.verifyCode(requestParameters.verifyCodeRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * 회원가입 시 이메일 주소의 사용 가능 여부를 확인합니다.
     * @summary 이메일 중복 확인
     * @param {AuthApiCheckEmailAvailabilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    checkEmailAvailability(requestParameters: AuthApiCheckEmailAvailabilityRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailabilityResponseWrapper>;

    /**
     * 회원가입 시 사용자 ID의 사용 가능 여부를 확인합니다.
     * @summary 사용자 ID 중복 확인
     * @param {AuthApiCheckUserIdAvailabilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    checkUserIdAvailability(requestParameters: AuthApiCheckUserIdAvailabilityRequest, options?: RawAxiosRequestConfig): AxiosPromise<AvailabilityResponseWrapper>;

    /**
     * 기존 계정에 소셜 계정 연결을 승인 또는 거부합니다.
     * @summary 소셜 계정 연결 확인
     * @param {AuthApiConfirmSocialLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    confirmSocialLink(requestParameters: AuthApiConfirmSocialLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseWrapper>;

    /**
     * 소셜 로그인 후 서버에서 발급된 임시 인증 코드를 토큰으로 교환합니다.
     * @summary 임시 인증 코드를 실제 토큰으로 교환
     * @param {AuthApiExchangeAuthCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    exchangeAuthCode(requestParameters: AuthApiExchangeAuthCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseWrapper>;

    /**
     * 인증된 이메일 또는 전화번호를 통해 사용자 아이디(이메일)를 찾습니다. 먼저 send-verification-code 호출 후 인증 코드를 발급받아야 합니다.
     * @summary 아이디 찾기
     * @param {AuthApiFindIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    findId(requestParameters: AuthApiFindIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<FindIdResponseWrapper>;

    /**
     * 이메일과 비밀번호로 로그인하고 토큰을 발급합니다.
     * @summary 로그인
     * @param {AuthApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    login(requestParameters: AuthApiLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseWrapper>;

    /**
     * 사용자를 로그아웃하고 토큰을 무효화합니다.
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    logout(options?: RawAxiosRequestConfig): AxiosPromise<LogoutResponseWrapper>;

    /**
     * 리프레시 토큰을 사용하여 새로운 액세스 토큰을 발급합니다.
     * @summary 토큰 갱신
     * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    refreshToken(requestParameters: AuthApiRefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseWrapper>;

    /**
     * 인증된 사용자의 비밀번호를 재설정합니다. 먼저 send-verification-code 호출 후 인증 코드를 발급받아야 합니다.
     * @summary 비밀번호 재설정
     * @param {AuthApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    resetPassword(requestParameters: AuthApiResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResetPasswordResponseWrapper>;

    /**
     * 멘토 사용자가 사용할 프로필(mentee/mentor)을 선택합니다. activeProfile 메타데이터가 포함된 새로운 Access Token을 발급받습니다.
     * @summary 프로필 선택
     * @param {AuthApiSelectProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    selectProfile(requestParameters: AuthApiSelectProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseWrapper>;

    /**
     * 이메일 또는 전화번호로 인증 코드를 발송합니다. 아이디 찾기나 비밀번호 재설정을 위해 사용됩니다.
     * @summary 인증 코드 발송
     * @param {AuthApiSendVerificationCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    sendVerificationCode(requestParameters: AuthApiSendVerificationCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<VerificationCodeResponseWrapper>;

    /**
     * 액세스 토큰의 유효성을 검증합니다.
     * @summary 토큰 검증
     * @param {AuthApiValidateTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    validateToken(requestParameters: AuthApiValidateTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ValidationResultResponseWrapper>;

    /**
     * 발송된 인증 코드의 유효성을 검증합니다. 이 과정을 통해 인증을 완료할 수 있습니다.
     * @summary 인증 코드 확인
     * @param {AuthApiVerifyCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    verifyCode(requestParameters: AuthApiVerifyCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<EmailVerificationResultResponseWrapper>;

}

/**
 * Request parameters for checkEmailAvailability operation in AuthApi.
 * @export
 * @interface AuthApiCheckEmailAvailabilityRequest
 */
export interface AuthApiCheckEmailAvailabilityRequest {
    /**
     * 
     * @type {CheckEmailAvailabilityRequestDto}
     * @memberof AuthApiCheckEmailAvailability
     */
    readonly checkEmailAvailabilityRequestDto: CheckEmailAvailabilityRequestDto
}

/**
 * Request parameters for checkUserIdAvailability operation in AuthApi.
 * @export
 * @interface AuthApiCheckUserIdAvailabilityRequest
 */
export interface AuthApiCheckUserIdAvailabilityRequest {
    /**
     * 
     * @type {CheckUserIdAvailabilityRequestDto}
     * @memberof AuthApiCheckUserIdAvailability
     */
    readonly checkUserIdAvailabilityRequestDto: CheckUserIdAvailabilityRequestDto
}

/**
 * Request parameters for confirmSocialLink operation in AuthApi.
 * @export
 * @interface AuthApiConfirmSocialLinkRequest
 */
export interface AuthApiConfirmSocialLinkRequest {
    /**
     * 
     * @type {ConfirmSocialLinkRequestDto}
     * @memberof AuthApiConfirmSocialLink
     */
    readonly confirmSocialLinkRequestDto: ConfirmSocialLinkRequestDto
}

/**
 * Request parameters for exchangeAuthCode operation in AuthApi.
 * @export
 * @interface AuthApiExchangeAuthCodeRequest
 */
export interface AuthApiExchangeAuthCodeRequest {
    /**
     * 
     * @type {ExchangeAuthCodeRequestDto}
     * @memberof AuthApiExchangeAuthCode
     */
    readonly exchangeAuthCodeRequestDto: ExchangeAuthCodeRequestDto
}

/**
 * Request parameters for findId operation in AuthApi.
 * @export
 * @interface AuthApiFindIdRequest
 */
export interface AuthApiFindIdRequest {
    /**
     * 
     * @type {FindIdRequestDto}
     * @memberof AuthApiFindId
     */
    readonly findIdRequestDto: FindIdRequestDto
}

/**
 * Request parameters for login operation in AuthApi.
 * @export
 * @interface AuthApiLoginRequest
 */
export interface AuthApiLoginRequest {
    /**
     * 
     * @type {LoginRequestDto}
     * @memberof AuthApiLogin
     */
    readonly loginRequestDto: LoginRequestDto
}

/**
 * Request parameters for refreshToken operation in AuthApi.
 * @export
 * @interface AuthApiRefreshTokenRequest
 */
export interface AuthApiRefreshTokenRequest {
    /**
     * 
     * @type {RefreshTokenRequestDto}
     * @memberof AuthApiRefreshToken
     */
    readonly refreshTokenRequestDto: RefreshTokenRequestDto
}

/**
 * Request parameters for resetPassword operation in AuthApi.
 * @export
 * @interface AuthApiResetPasswordRequest
 */
export interface AuthApiResetPasswordRequest {
    /**
     * 
     * @type {ResetPasswordRequestDto}
     * @memberof AuthApiResetPassword
     */
    readonly resetPasswordRequestDto: ResetPasswordRequestDto
}

/**
 * Request parameters for selectProfile operation in AuthApi.
 * @export
 * @interface AuthApiSelectProfileRequest
 */
export interface AuthApiSelectProfileRequest {
    /**
     * 
     * @type {object}
     * @memberof AuthApiSelectProfile
     */
    readonly body: object
}

/**
 * Request parameters for sendVerificationCode operation in AuthApi.
 * @export
 * @interface AuthApiSendVerificationCodeRequest
 */
export interface AuthApiSendVerificationCodeRequest {
    /**
     * 
     * @type {SendVerificationCodeRequestDto}
     * @memberof AuthApiSendVerificationCode
     */
    readonly sendVerificationCodeRequestDto: SendVerificationCodeRequestDto
}

/**
 * Request parameters for validateToken operation in AuthApi.
 * @export
 * @interface AuthApiValidateTokenRequest
 */
export interface AuthApiValidateTokenRequest {
    /**
     * 
     * @type {ValidateTokenRequestDto}
     * @memberof AuthApiValidateToken
     */
    readonly validateTokenRequestDto: ValidateTokenRequestDto
}

/**
 * Request parameters for verifyCode operation in AuthApi.
 * @export
 * @interface AuthApiVerifyCodeRequest
 */
export interface AuthApiVerifyCodeRequest {
    /**
     * 
     * @type {VerifyCodeRequestDto}
     * @memberof AuthApiVerifyCode
     */
    readonly verifyCodeRequestDto: VerifyCodeRequestDto
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * 회원가입 시 이메일 주소의 사용 가능 여부를 확인합니다.
     * @summary 이메일 중복 확인
     * @param {AuthApiCheckEmailAvailabilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public checkEmailAvailability(requestParameters: AuthApiCheckEmailAvailabilityRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).checkEmailAvailability(requestParameters.checkEmailAvailabilityRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 회원가입 시 사용자 ID의 사용 가능 여부를 확인합니다.
     * @summary 사용자 ID 중복 확인
     * @param {AuthApiCheckUserIdAvailabilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public checkUserIdAvailability(requestParameters: AuthApiCheckUserIdAvailabilityRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).checkUserIdAvailability(requestParameters.checkUserIdAvailabilityRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 기존 계정에 소셜 계정 연결을 승인 또는 거부합니다.
     * @summary 소셜 계정 연결 확인
     * @param {AuthApiConfirmSocialLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public confirmSocialLink(requestParameters: AuthApiConfirmSocialLinkRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).confirmSocialLink(requestParameters.confirmSocialLinkRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 소셜 로그인 후 서버에서 발급된 임시 인증 코드를 토큰으로 교환합니다.
     * @summary 임시 인증 코드를 실제 토큰으로 교환
     * @param {AuthApiExchangeAuthCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public exchangeAuthCode(requestParameters: AuthApiExchangeAuthCodeRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).exchangeAuthCode(requestParameters.exchangeAuthCodeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 인증된 이메일 또는 전화번호를 통해 사용자 아이디(이메일)를 찾습니다. 먼저 send-verification-code 호출 후 인증 코드를 발급받아야 합니다.
     * @summary 아이디 찾기
     * @param {AuthApiFindIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public findId(requestParameters: AuthApiFindIdRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).findId(requestParameters.findIdRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일과 비밀번호로 로그인하고 토큰을 발급합니다.
     * @summary 로그인
     * @param {AuthApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(requestParameters: AuthApiLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(requestParameters.loginRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자를 로그아웃하고 토큰을 무효화합니다.
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 리프레시 토큰을 사용하여 새로운 액세스 토큰을 발급합니다.
     * @summary 토큰 갱신
     * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(requestParameters: AuthApiRefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(requestParameters.refreshTokenRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 인증된 사용자의 비밀번호를 재설정합니다. 먼저 send-verification-code 호출 후 인증 코드를 발급받아야 합니다.
     * @summary 비밀번호 재설정
     * @param {AuthApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resetPassword(requestParameters: AuthApiResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).resetPassword(requestParameters.resetPasswordRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 멘토 사용자가 사용할 프로필(mentee/mentor)을 선택합니다. activeProfile 메타데이터가 포함된 새로운 Access Token을 발급받습니다.
     * @summary 프로필 선택
     * @param {AuthApiSelectProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public selectProfile(requestParameters: AuthApiSelectProfileRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).selectProfile(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일 또는 전화번호로 인증 코드를 발송합니다. 아이디 찾기나 비밀번호 재설정을 위해 사용됩니다.
     * @summary 인증 코드 발송
     * @param {AuthApiSendVerificationCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public sendVerificationCode(requestParameters: AuthApiSendVerificationCodeRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).sendVerificationCode(requestParameters.sendVerificationCodeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 액세스 토큰의 유효성을 검증합니다.
     * @summary 토큰 검증
     * @param {AuthApiValidateTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public validateToken(requestParameters: AuthApiValidateTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).validateToken(requestParameters.validateTokenRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 발송된 인증 코드의 유효성을 검증합니다. 이 과정을 통해 인증을 완료할 수 있습니다.
     * @summary 인증 코드 확인
     * @param {AuthApiVerifyCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyCode(requestParameters: AuthApiVerifyCodeRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyCode(requestParameters.verifyCodeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}

