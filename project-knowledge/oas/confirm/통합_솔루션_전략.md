# 통합 솔루션 전략 - 단순화된 래핑 방식 (업데이트: 2025-01-29)

> **상태**: 복잡한 아키텍처에서 단순한 래핑 방식으로 전환
> **근거**: UserApiFp 패턴과 FP 함수의 axios 주입 구조 발견으로 대폭 단순화 가능

## 🎯 전략 개요

**기존 인프라를 100% 보존**하면서 **생성된 OAS 코드를 직접 래핑**하는 단순하고 직관적인 통합 방식입니다.

### 핵심 철학
- **최대한 단순하게**: 복잡한 Adapter/Configuration 패턴 제거
- **기존 시스템 100% 보존**: BaseApiService, customAxios, useBaseMutation 그대로 유지
- **Zero Breaking Changes**: 현재 작동하는 기능에 영향 없음
- **점진적 타입 교체**: 수동 타입을 생성된 정확한 타입으로 단계적 교체

## 🏗️ 단순화된 아키텍처 설계

### 레이어별 구조 (기존 구조 최대한 보존)
```
packages/api-client/        # 생성된 코드 (건드리지 않음)
├── src/
│   ├── services/          # UserApiFp 등 FP 함수들
│   ├── types/            # 생성된 정확한 타입들
│   └── index.ts

apps/web/src/shared/api/
├── core/                  # 기존 핵심 인프라 (그대로 유지)
│   ├── axios.ts          # customAxios (인증 인터셉터 포함)
│   ├── base-api-service.ts # BaseApiService 추상 클래스
│   ├── error-handler.ts  # 에러 처리 시스템
│   └── types.ts          # 기존 공통 타입들
└── services/             # 래핑 서비스 레이어 (내부 구현만 변경)
    ├── user-api.service.ts # UserApiFp를 래핑
    ├── auth-api.service.ts # AuthApiFp를 래핑
    └── mail-api.service.ts # MailApiFp를 래핑
```

### 단순화된 데이터 흐름
```
[UserApiFp] → [customAxios 주입] → [래핑 서비스] → [Component]
     ↓             ↓                 ↓            ↓
 [FP 함수]    [인증 자동처리]    [BaseApiService]  [기존 TanStack Query]
 [순수함수]    [에러 처리]       [변환 로직]       [패턴 그대로 유지]
```

## 🔧 단순화된 솔루션 상세

### 1. Auth.js 통합 솔루션 - 직접 주입 방식

#### **FP 함수에 customAxios 직접 주입 (매우 간단)**

```typescript
// 기존 인증 axios 그대로 사용 (apps/web/src/shared/api/core/axios.ts)
import { apiClient } from './axios' // 이미 인증 인터셉터 포함

// 새로운 래핑 서비스에서 직접 주입
// apps/web/src/shared/api/services/user-api.service.ts
import { UserApiFp } from '@repo/api-client'
import { BaseApiService } from '../core/base-api-service'
import { apiClient } from '../core/axios'

export class UserApiService extends BaseApiService {
  constructor() {
    super('/users') // BaseApiService 패턴 유지
  }

  async getAllUsers(params?: GetUsersParams) {
    try {
      // 1. FP 함수 호출
      const getAllUsersFn = UserApiFp.getAllUsers(params)
      
      // 2. 인증된 axios 인스턴스 주입
      const response = await getAllUsersFn(apiClient.instance)
      
      // 3. 기존 BaseApiService 패턴으로 응답 처리
      return this.handlePaginatedResponse(response.data)
    } catch (error) {
      // 4. 기존 에러 처리 시스템 활용
      throw this.handleError(error)
    }
  }
}
```

#### **장점: 복잡한 Configuration 매니저 불필요**

```typescript
// 기존 시스템을 그대로 활용
// - customAxios: 이미 토큰 자동 주입, 갱신 로직 포함
// - BaseApiService: 검증된 에러 처리, 응답 변환 로직
// - FP 함수: runtime에 axios 인스턴스를 받는 구조

// 결과: 세 개가 완벽하게 조합됨
const response = await UserApiFp.getAllUsers(params)(customAxios)
//                    ↑ 생성된 FP 함수    ↑ 인증된 axios
```

### 2. TanStack Query 통합 솔루션 - 기존 패턴 100% 유지

#### **BaseApiService를 상속받는 단순한 래핑 서비스**

```typescript
// apps/web/src/shared/api/services/user-api.service.ts
import { UserApiFp } from '@repo/api-client'
import type { 
  UserListResponseWrapper,
  GetUsersParams,
  CreateUserRequestDto 
} from '@repo/api-client/types'
import { BaseApiService } from '../core/base-api-service'
import { apiClient } from '../core/axios'

export class UserApiService extends BaseApiService {
  constructor() {
    super('/users') // 기존 BaseApiService 패턴
  }
  
  // 기존 메서드 시그니처 유지, 내부 구현만 변경
  async getAllUsers(params?: GetUsersParams) {
    try {
      const fn = UserApiFp.getAllUsers(params)
      const response = await fn(apiClient.instance)
      return this.transformToAppFormat(response.data)
    } catch (error) {
      throw this.handleError(error) // BaseApiService 에러 처리
    }
  }
  
  async createUser(data: CreateUserRequestDto) {
    try {
      const fn = UserApiFp.createUser(data)
      const response = await fn(apiClient.instance)
      return this.transformToAppFormat(response.data)
    } catch (error) {
      throw this.handleError(error)
    }
  }
}

export const userApiService = new UserApiService()
```

#### **기존 features 레벨 코드는 변경 없음**

```typescript
// apps/web/src/features/user/apis/queries.ts (기존 파일, 변경 없음)
import { userApiService } from '@/shared/api/services/user-api.service'
import type { GetUsersParams } from '@repo/api-client/types' // 타입만 import 변경

// 기존 쿼리 팩토리 패턴 그대로 유지
export const userKeys = createQueryKeys("users", {
  all: null,
  lists: () => ["list"] as const,
  list: (params: GetUsersParams) => [{ ...params }] as const,
  details: () => ["detail"] as const,
  detail: (id: string) => [id] as const,
})

// 기존 쿼리 정의 그대로 유지 (변경 사항 없음)
export const userQueries = {
  list: (params: GetUsersParams) => ({
    queryKey: userKeys.list(params).queryKey,
    queryFn: () => userApiService.getAllUsers(params), // 내부적으로만 생성된 API 사용
  }),
  
  detail: (id: string) => ({
    queryKey: userKeys.detail(id).queryKey,
    queryFn: () => userApiService.getUserById(id),
  })
}
```

#### **useBaseMutation도 변경 없음**

```typescript
// apps/web/src/features/user/apis/mutations.ts (기존 파일, 변경 없음)
import { useBaseMutation } from '@/shared/hooks/useBaseMutation'
import { userApiService } from '@/shared/api/services/user-api.service'
import { userKeys } from './queries'
import type { CreateUserRequestDto } from '@repo/api-client/types' // 타입만 변경

// 기존 useBaseMutation 패턴 완전히 그대로 유지
export const useCreateUser = () => {
  return useBaseMutation<UserResponseDto, Error, CreateUserRequestDto>({
    queryKey: userKeys.lists().queryKey,
    mutationFn: (data) => userApiService.createUser(data), // 서비스만 교체
    successMessage: '사용자가 성공적으로 생성되었습니다.',
    errorMessage: '사용자 생성에 실패했습니다.',
    onSuccess: (data) => {
      // 낙관적 업데이트 로직 그대로 유지
      queryClient.invalidateQueries(userKeys.lists())
    }
  })
}
```

### 3. 코드 격리 전략 - 물리적 분리로 자연스럽게 해결

#### **단순한 패키지 분리로 충분**

```bash
packages/api-client/        # 생성된 코드 (건드리지 않음)
├── src/
│   ├── services/user-api.ts    # UserApiFp 등
│   ├── types/user/*.ts         # 생성된 타입들
│   └── index.ts
├── package.json
└── .gitignore              # 필요시 생성된 파일들 제외

apps/web/                   # 비즈니스 코드
├── src/shared/api/services/    # 래핑 서비스들
└── src/features/               # 기존 코드 그대로
```

**장점:**
- generated/ 폴더 불필요
- 복사 스크립트 불필요  
- 권한 설정 불필요
- 물리적으로 완전 분리되어 안전

#### **Package.json 스크립트만 업데이트**

```json
// 루트 package.json
{
  "scripts": {
    "gen:api": "cd apps/api && pnpm export:swagger && cd ../../packages/api-client && pnpm generate",
    "dev:api": "pnpm gen:api && pnpm dev"
  }
}
```

### 4. API 변경 알림 자동화 - 현재는 선택사항

#### **현실적인 접근: 당장은 불필요**

**이유:**
- 팀 규모가 크지 않음
- API 변경 빈도가 높지 않음  
- 기본 통합이 더 시급
- 복잡성 대비 효용이 낮음

**향후 필요시 고려할 수 있는 옵션:**
- GitHub Actions 기반 변경 감지
- Slack 알림 시스템
- 하지만 현재는 수동 프로세스로도 충분

## 🎯 단순화된 마이그레이션 전략

### Phase 1: 래핑 서비스 구현 (3-5일)
1. **UserApiService 구현** (1일)
   - BaseApiService 상속
   - UserApiFp 함수들을 래핑
   - 기본 CRUD 메서드 구현

2. **AuthApiService 구현** (1일)
   - 인증 API 특수 처리 (토큰 없이 호출 가능)
   - 로그인/로그아웃 API 래핑

3. **기타 핵심 API 서비스** (2-3일)
   - MailApiService
   - BaekjoonApiService
   - 필요한 다른 서비스들

### Phase 2: 점진적 전환 (1-2주)
1. **타입 교체** (3-5일)
   - 수동 타입을 생성된 타입으로 점진적 교체
   - features 레벨 코드의 import 문만 변경
   - 메서드 시그니처는 그대로 유지

2. **테스트 및 검증** (2-3일)
   - 기존 기능 정상 작동 확인
   - 타입 안전성 검증
   - 성능 영향 측정

3. **문서화** (1-2일)
   - 개발자 가이드 작성
   - 새로운 API 추가 방법 문서화

## 📊 예상 효과 (대폭 개선)

### ✅ 즉시 효과 (기존 대비 훨씬 단순)
- **개발 시간 단축**: 4-6주 → 2-3주로 50% 단축
- **복잡성 대폭 감소**: Adapter 패턴, Configuration 매니저 불필요
- **학습 비용 제로**: 기존 패턴 100% 유지
- **타입 안전성 향상**: 수동 타입 → 정확한 생성 타입

### 🚀 장기 효과
- **유지보수성**: 백엔드 변경사항 자동 반영 (타입 레벨)
- **개발 생산성**: 자동 생성 + 검증된 기존 패턴 조합
- **안정성**: 기존 검증된 인프라 그대로 활용

### 📈 개발팀 이점
- **Zero Breaking Changes**: 현재 코드 그대로 동작
- **점진적 개선**: 타입만 단계적으로 교체
- **직관적 구조**: 복잡한 레이어 없이 바로 이해 가능

**결론**: 복잡한 아키텍처 설계 없이도 **기존 인프라의 모든 장점을 유지**하면서 **OAS 자동 생성의 이점**을 취할 수 있는 최적의 단순한 접근법입니다.

## 🔗 관련 문서
- [4가지_핵심문제_분석.md](./4가지_핵심문제_분석.md) - 해소된 문제점들 상세 분석
- [구현_로드맵.md](./구현_로드맵.md) - 단축된 2-3주 구현 계획