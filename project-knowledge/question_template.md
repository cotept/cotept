# 목표

인증 시스템을 담당하는 auth 모듈 구현

## 규칙

- 한국어로 답변하기
- 모르는 것은 brave-search로 검색하고 분석해서 답변하기
- 경로는 반드시 @/ 사용하기
- @nestjs/swagger mapped-types, class-validator, class-transformer 적극 사용하기
- DB는 오라클 19 버전이고 typeorm에서 지원하는 oracle 타입 확인하고 생성하기
- nestjs execption 무조건 활용하기 /home/hyun95/development/projects/cote_pt_2024/cotept/apps/api/src/shared/infrastructure/common/filters/api-error.filter.ts 에서 잡아줘서 예외 자체가 응답으로 넘어감
- /home/hyun95/development/projects/cote_pt_2024/cotept/apps/api/src/shared/infrastructure/dto/api-response.dto.ts 공통 응답을 위한 클래스 활용하기
- 단계별로 진행하기
- mapper class는 class-transformer 적극 사용하기
- /domain은 순수하게 작성하기 어떤 라이브러리도 사용하지 않는다
- secure-filesystem-server 를 사용하여 직접 로컬파일 CRUD 하기

- @nestjs/swagger를 사용해서 mapped-types를 활용하면 DTO 클래스에 class-validator, class-transformer 사용하고 CRUD용 DTO에 mapped-types를 적용하면 CRUD DTO 각각 불필요한 중복을 줄인다.

## 참조

- 프로젝트 지식
- /home/hyun95/development/projects/cote_pt_2024/cotept/apps/api/src/modules/user
  반드시 user 모듈과 동일한 구조로 작성한다
- /home/hyun95/development/projects/cote_pt_2024/cotept/project-knowledge/database-schema.md
- /home/hyun95/development/projects/cote_pt_2024/cotept/project-knowledge/auth-system-design.md

## 작업 로컬 파일 경로

/home/hyun95/development/projects/cote_pt_2024/cotept/apps/api/src/modules/auth

## 구현 계획 및 단계

### 구현 현황 및 계획

#### 구현 완료된 모듈

- **User 모듈**: `/home/hyun95/development/projects/cote_pt_2024/cotept/apps/api/src/modules/user` 경로에 이미 구현 완료
  - 사용자 엔티티 및 값 객체 (Email, Name, Password, PhoneNumber)
  - 사용자 CRUD 유스케이스
  - TypeORM 기반 레포지토리
  - REST API 컨트롤러
  - 비밀번호 관리 서비스

#### 남은 구현 단계

1. **인증 모듈 기본 구조 설정** (2-3일)

   - 기존 User 모듈과 통합
   - 인증 관련 도메인 모델 설계
   - 핵심 포트 정의

2. **JWT 인증 기능 구현** (5-6일)

   - JWT 서비스 구현
   - 로그인 유스케이스 구현
   - 토큰 검증 유스케이스 구현
   - 인증 컨트롤러 구현

3. **Redis 통합** (3-4일)

   - Redis 연결 설정
   - 토큰 저장소 포트 및 어댑터 구현

4. **토큰 블랙리스트 구현** (3-4일)

   - 블랙리스트 서비스 구현
   - 로그아웃 유스케이스 구현
   - JWT 가드 수정

5. **토큰 로테이션 구현** (4-5일)

   - 토큰 패밀리 개념 구현
   - 토큰 갱신 유스케이스 구현

6. **CSRF 보호 구현** (3-4일)

   - CSRF 토큰 서비스 구현
   - CSRF 가드 구현
   - 로그인 유스케이스 수정

7. **소셜 로그인 통합** (5-6일)

   - Passport 전략 구현
   - 소셜 인증 어댑터 구현
   - 소셜 로그인 유스케이스 구현
   - OAuth 콜백 컨트롤러 구현

8. **Origin/Referer 검증 및 CORS 설정** (2-3일)

   - Origin/Referer 검증 미들웨어 구현
   - CORS 정책 설정
   - 보안 헤더 구성

9. **네이버 클라우드 알림 서비스 통합** (5-6일)

   - 네이버 클라우드 API 어댑터 구현
   - 이메일/SMS 발송 서비스 구현
   - 인증 코드 관리 서비스 구현

10. **계정 복구 기능 구현** (4-5일)

    - 아이디 찾기 기능 구현
    - 비밀번호 재설정 기능 구현

11. **Silent Refresh 구현** (4-5일)

    - 토큰 갱신 엔드포인트 구현
    - 클라이언트 통합 가이드 작성

12. **테스트 및 최적화** (5-6일)
    - 단위 테스트 작성
    - 통합 테스트 작성
    - 성능 최적화
    - 문서 업데이트# 코테피티(Cotept) 인증 시스템 구현 가이드

## 목차

1. [소개 및 개요](#1-소개-및-개요)
2. [아키텍처 설계](#2-아키텍처-설계)
3. [인증 전략 및 흐름](#3-인증-전략-및-흐름)
4. [토큰 관리 시스템](#4-토큰-관리-시스템)
5. [계정 관리 기능](#5-계정-관리-기능)
6. [소셜 로그인 통합](#6-소셜-로그인-통합)
7. [보안 고려사항](#7-보안-고려사항)
8. [알림 시스템 통합](#8-알림-시스템-통합)
9. [구현 계획 및 단계](#9-구현-계획-및-단계)
10. [테스트 전략](#10-테스트-전략)

## 1. 소개 및 개요

### 1.1 배경 및 목적

코테피티(Cotept) 인증 시스템은 코딩 테스트 멘토링 서비스의 사용자 인증, 권한 관리, 개인정보 보호를 위한 핵심 시스템입니다. 이 시스템은 JWT 기반의 안전하고 확장 가능한 인증 메커니즘을 제공하며, 헥사고날 아키텍처와 도메인 주도 설계(DDD) 원칙을 따릅니다.

### 1.2 주요 기능

- JWT 기반 액세스 토큰 및 리프레시 토큰 인증
- 토큰 블랙리스트 및 로테이션 메커니즘
- 소셜 로그인 지원 (Google, Kakao, Naver, GitHub)
- 이메일 및 SMS 기반 본인 인증
- 아이디 찾기 및 비밀번호 재설정
- CSRF 보호 및 Origin 검증
- Silent Refresh 기능

### 1.3 기술 스택

- **백엔드**: NestJS (TypeScript)
- **데이터베이스**: Oracle 19c
- **캐시/세션**: Redis
- **인증 프로토콜**: JWT
- **소셜 로그인**: Passport.js
- **알림 서비스**: 네이버 클라우드 (이메일, SMS)

## 2. 아키텍처 설계

### 2.1 헥사고날 아키텍처

코테피티 인증 시스템은 헥사고날 아키텍처(육각형 아키텍처 또는 포트와 어댑터 패턴)를 채택하여 코어 비즈니스 로직과 외부 의존성을 명확히 분리합니다.

#### 2.1.1 계층 구조

- **도메인 계층**: 핵심 비즈니스 엔티티, 값 객체, 도메인 이벤트
- **애플리케이션 계층**: 유스케이스, 포트(인터페이스) 정의
- **인프라스트럭처 계층**: 어댑터, 외부 서비스 연동

#### 2.1.2 포트와 어댑터

- **인바운드 포트(Primary Ports)**: 애플리케이션에 들어오는 요청 관련 인터페이스

  - 로그인 유스케이스
  - 회원가입 유스케이스
  - 토큰 갱신 유스케이스 등

- **아웃바운드 포트(Secondary Ports)**: 애플리케이션에서 외부로 나가는 요청 관련 인터페이스

  - 사용자 레포지토리
  - 토큰 저장소
  - 알림 서비스

- **인바운드 어댑터(Primary Adapters)**: 외부에서 애플리케이션으로의 진입점

  - REST API 컨트롤러
  - GraphQL 리졸버
  - WebSocket 핸들러

- **아웃바운드 어댑터(Secondary Adapters)**: 애플리케이션에서 외부 서비스로의 연결점
  - TypeORM 레포지토리 구현체
  - Redis 토큰 저장소 구현체
  - 네이버 클라우드 알림 서비스 어댑터

### 2.2 현재 구현된 사용자 모듈 구조

현재 `/home/hyun95/development/projects/cote_pt_2024/cotept/apps/api/src/modules/user` 경로에 이미 구현된 사용자(User) 모듈이 존재합니다. 이 모듈은 헥사고날 아키텍처를 따르고 있으며 다음과 같은 구조로 구성되어 있습니다:

```
user/
├── application/
│   ├── dtos/           # 애플리케이션 레이어 DTO
│   ├── mappers/        # 도메인-애플리케이션 매퍼
│   ├── ports/
│   │   ├── in/         # 인바운드 포트(유스케이스 인터페이스)
│   │   └── out/        # 아웃바운드 포트(레포지토리 등 인터페이스)
│   └── services/
│       ├── facade/     # 퍼사드 서비스
│       └── usecases/   # 유스케이스 구현체
├── domain/
│   ├── model/          # 도메인 모델/엔티티
│   └── vo/             # 값 객체(Value Objects)
└── infrastructure/
    ├── adapter/
    │   ├── in/
    │   │   ├── controllers/ # REST API 컨트롤러
    │   │   └── mappers/     # 요청 DTO 매퍼
    │   └── out/
    │       ├── persistence/ # 데이터베이스 어댑터
    │       └── services/    # 외부 서비스 어댑터
    ├── common/          # 공통 인프라 코드
    └── dtos/            # 인프라 레이어 DTO
        ├── request/     # 요청 DTO
        └── response/    # 응답 DTO
```

#### 2.2.1 구현된 주요 구성 요소

- **도메인 모델**:

  - `User` 엔티티: 사용자 계정 정보, 역할, 상태 등 관리
  - 값 객체: Email, Name, Password, PhoneNumber 등

- **유스케이스**:

  - `GetUserUseCase`: 사용자 조회
  - `CreateUserUseCase`: 사용자 생성
  - `UpdateUserUseCase`: 사용자 정보 업데이트
  - `DeleteUserUseCase`: 사용자 삭제
  - `ChangePasswordUseCase`: 비밀번호 변경

- **인프라스트럭처**:
  - `UserController`: 사용자 관련 REST API 엔드포인트
  - `TypeOrmUserRepository`: Oracle DB를 사용한 사용자 레포지토리
  - `PasswordService`: 비밀번호 해싱, 검증 서비스

#### 2.2.2 현재 지원하는 기능

- 사용자 CRUD (생성, 조회, 수정, 삭제)
- 비밀번호 관리 (해싱, 변경)
- 사용자 역할 관리 (MENTEE, MENTOR, ADMIN)
- 사용자 상태 관리 (ACTIVE, INACTIVE, SUSPENDED)

### 2.3 인증 시스템을 위한 추가 도메인 모델

기존 User 모듈을 기반으로 아래 도메인 모델/엔티티를 추가 구현해야 합니다:

- **LoginSession**: 로그인 세션 정보
- **TokenPayload**: 토큰에 포함되는 페이로드 정보
- **SocialProfile**: 소셜 로그인 프로필 정보
- **AuthVerification**: 인증 코드 및 검증 정보

## 3. 인증 전략 및 흐름

### 3.1 JWT 기반 인증

#### 3.1.1 액세스 토큰

- 짧은 유효기간 (15~30분)
- 사용자 식별 정보 및 권한 정보 포함
- 프론트엔드에서 메모리(변수)에 저장
- Authorization 헤더를 통해 요청에 포함

#### 3.1.2 리프레시 토큰

- 긴 유효기간 (7일)
- 토큰 패밀리 ID 포함
- HTTP-only, Secure, SameSite=Strict 쿠키로 설정
- 자동으로 요청에 포함되어 액세스 토큰 갱신에 사용

### 3.2 인증 흐름

1. **회원가입**:

   - 사용자 정보 입력 및 유효성 검증
   - 이메일 인증 또는 SMS 인증을 통한 본인 확인
   - 사용자 계정 생성

2. **로그인**:

   - 이메일/비밀번호 또는 소셜 로그인을 통한 인증
   - 액세스 토큰과 리프레시 토큰 발급
   - 로그인 세션 기록

3. **인증된 요청**:

   - 클라이언트는 액세스 토큰을 Authorization 헤더에 포함
   - 서버는 토큰의 유효성과 블랙리스트 여부 확인
   - 유효한 경우 요청 처리, 그렇지 않으면 401 응답

4. **토큰 갱신**:

   - 액세스 토큰 만료 시 리프레시 토큰으로 갱신
   - 새 액세스 토큰과 리프레시 토큰 발급 (토큰 로테이션)
   - 이전 리프레시 토큰 무효화

5. **로그아웃**:
   - 액세스 토큰 블랙리스트에 추가
   - 리프레시 토큰 쿠키 삭제
   - 로그인 세션 종료

### 3.3 Silent Refresh

액세스 토큰이 만료되기 직전에 백그라운드에서 자동으로 갱신하는 메커니즘입니다:

1. 프론트엔드에서 액세스 토큰 만료 시간 모니터링
2. 만료 5분 전에 토큰 갱신 요청 실행
3. 리프레시 토큰은 쿠키에 있어 자동으로 전송됨
4. 새로운 액세스 토큰을 받아 메모리에 저장
5. 사용자 경험 방해 없이 인증 유지

## 4. 토큰 관리 시스템

### 4.1 토큰 블랙리스트

- **목적**: 발급된 JWT의 무효화 관리
- **구현**: Redis를 사용하여 블랙리스트 저장
- **동작 방식**:
  1. 로그아웃 시 액세스 토큰을 블랙리스트에 추가
  2. 토큰 ID를 키로, 값은 간단한 플래그로 저장
  3. Redis의 TTL 기능을 사용하여 원래 토큰 만료 시간과 동일하게 설정
  4. 인증 요청마다 토큰이 블랙리스트에 있는지 확인

### 4.2 토큰 로테이션

- **목적**: 리프레시 토큰의 보안 강화 및 도난 감지
- **구현**: 패밀리 ID 기반 토큰 로테이션
- **동작 방식**:
  1. 각 리프레시 토큰에 고유한 패밀리 ID 포함
  2. Redis에 토큰 패밀리 정보 저장 (`refresh:{userId}:{familyId}`)
  3. 토큰 갱신 시 이전 패밀리 ID 삭제 및 새 패밀리 ID 생성
  4. 유효하지 않은 패밀리 ID로 요청이 오면 토큰 도난으로 간주
  5. 도난 감지 시 해당 사용자의 모든 토큰 무효화

### 4.3 Redis를 활용한 토큰 저장

- **블랙리스트 저장**: `bl:{tokenId}` 형식의 키로 저장
- **리프레시 토큰 패밀리**: `refresh:{userId}:{familyId}` 형식으로 저장
- **CSRF 토큰**: `csrf:{userId}:{token}` 형식으로 저장
- **인증 코드**: `email_verify:{email}` 또는 `sms_verify:{phoneNumber}` 형식으로 저장

### 4.4 토큰 페이로드 설계

#### 4.4.1 액세스 토큰 페이로드

```
{
  "sub": "사용자 ID",
  "email": "사용자 이메일",
  "role": "사용자 역할(MENTEE/MENTOR/ADMIN)",
  "iat": 발급 시간,
  "exp": 만료 시간,
  "jti": "토큰 고유 ID"
}
```

#### 4.4.2 리프레시 토큰 페이로드

```
{
  "sub": "사용자 ID",
  "family": "패밀리 ID",
  "iat": 발급 시간,
  "exp": 만료 시간,
  "jti": "토큰 고유 ID"
}
```

## 5. 계정 관리 기능

### 5.1 회원가입

- **입력 정보**: 이메일, 비밀번호, 이름 등
- **유효성 검증**: 이메일 형식, 비밀번호 복잡도 등 검증
- **본인 확인**: 이메일 인증 또는 SMS 인증
- **약관 동의**: 필수 약관 동의 확인
- **계정 생성**: 비밀번호 해싱 후 사용자 정보 저장

### 5.2 로그인

- **인증 방식**: 이메일/비밀번호 또는 소셜 로그인
- **검증 과정**: 계정 존재 여부, 비밀번호 일치, 계정 상태 확인
- **토큰 발급**: 인증 성공 시 액세스 토큰과 리프레시 토큰 발급
- **보안 조치**: 로그인 시도 제한, 의심스러운 활동 감지

### 5.3 아이디 찾기

- **제공 방법**: 등록된 이메일 또는 전화번호로 찾기
- **보안 조치**: 이메일 일부 마스킹 처리하여 제공
- **구현 방식**: 사용자의 이메일 또는 전화번호를 통해 계정 정보 조회 후 알림 발송

### 5.4 비밀번호 재설정

- **요청 단계**: 이메일 주소 입력 → 인증 링크 발송
- **검증 단계**: 토큰 검증 → 사용자 확인 → 추가 인증(선택적)
- **재설정 단계**: 새 비밀번호 입력 → 비밀번호 변경 → 관련 세션 무효화
- **보안 조치**: 시간 제한 토큰, 일회용 링크, 재설정 후 알림

### 5.5 로그아웃

- **클라이언트 조치**: 액세스 토큰 삭제, 리프레시 토큰 쿠키 삭제
- **서버 조치**: 액세스 토큰 블랙리스트 추가, 세션 기록 업데이트

### 5.6 계정 관리

- **프로필 수정**: 개인 정보 업데이트
- **비밀번호 변경**: 현재 비밀번호 확인 후 새 비밀번호 설정
- **계정 삭제**: 확인 절차 후 계정 비활성화 또는 삭제
- **연결 계정 관리**: 소셜 계정 연결/해제

## 6. 소셜 로그인 통합

### 6.1 지원 소셜 로그인 제공자

- Google
- Kakao
- Naver
- GitHub

### 6.2 소셜 로그인 아키텍처

#### 6.2.1 Passport.js 전략

- 각 소셜 로그인 제공자별 Passport 전략 구현
- OAuth 2.0 프로토콜 기반 인증 구현
- 전략은 인프라 계층의 어댑터로 구현

#### 6.2.2 소셜 프로필 포트

- 외부 소셜 서비스에서 사용자 프로필을 가져오는 포트 정의
- 소셜 제공자별 어댑터에서 이 포트 구현
- 애플리케이션 계층은 이 포트를 통해 소셜 프로필 접근

### 6.3 소셜 로그인 흐름

1. **인증 요청**: 사용자가 소셜 로그인 버튼 클릭
2. **리다이렉트**: 해당 소셜 제공자의 인증 페이지로 리다이렉트
3. **인증**: 사용자가 소셜 계정으로 인증
4. **콜백 처리**: 소셜 제공자가 인증 코드와 함께 앱으로 리다이렉트
5. **토큰 교환**: 인증 코드로 액세스 토큰 요청
6. **프로필 조회**: 액세스 토큰으로 사용자 프로필 정보 요청
7. **계정 연결**: 이메일 기반으로 기존 계정 확인 또는 새 계정 생성
8. **토큰 발급**: JWT 액세스 토큰 및 리프레시 토큰 발급

### 6.4 소셜 계정 연동 전략

- **이메일 매칭**: 소셜 계정의 이메일과 기존 계정 이메일 매칭
- **사용자 선택**: 연동 또는 별도 계정 생성 선택권 제공
- **다중 소셜 연결**: 하나의 코테피티 계정에 여러 소셜 계정 연결 지원

## 7. 보안 고려사항

### 7.1 CSRF 보호

- **이중 제출 쿠키 패턴** 사용:
  1. 서버가 랜덤한 CSRF 토큰 생성
  2. 토큰을 JavaScript 접근 가능 쿠키와 응답 본문에 모두 전달
  3. 클라이언트는 상태 변경 요청 시 헤더에 토큰 포함
  4. 서버는 쿠키의 토큰과 헤더의 토큰 일치 여부 확인
  5. 불일치 시 요청 거부

### 7.2 Origin/Referer 검증

- **목적**: CSRF 보호 강화 및 API 무단 사용 방지
- **구현**:
  1. 상태 변경 요청의 Origin/Referer 헤더 검사
  2. 허용된 도메인 목록과 비교
  3. 일치하지 않는 Origin에서의 요청 거부

### 7.3 CORS 설정

- **허용 오리진**: 명시적으로 허용된 도메인만 설정
- **인증 설정**: `credentials: true`로 설정하여 쿠키 포함 요청 허용
- **헤더 제한**: 필요한 헤더만 허용
- **메서드 제한**: 필요한 HTTP 메서드만 허용
- **프리플라이트 캐싱**: 반복적인 OPTIONS 요청 감소를 위한 캐싱 적용

### 7.4 비밀번호 보안

- **해싱 알고리즘**: bcrypt 사용 (비용 팩터 10+)
- **솔팅**: 사용자별 고유 솔트 자동 생성
- **복잡도 요구사항**: 최소 8자, 대소문자, 숫자, 특수문자 조합
- **주기적 변경 유도**: 90일마다 비밀번호 변경 권장

### 7.5 속도 제한(Rate Limiting)

- **목적**: 무차별 대입 공격 및 DOS 공격 방지
- **대상 엔드포인트**: 로그인, 회원가입, 비밀번호 재설정, 인증 코드 발송
- **제한 기준**: IP 주소, 사용자 ID, 리소스 타입별 제한
- **구현**: Redis 기반 타임 윈도우 카운터

### 7.6 로깅 및 모니터링

- **로그 대상**: 인증 시도, 비밀번호 변경, 소셜 로그인 등 주요 보안 이벤트
- **로그 내용**: 시간, 이벤트 유형, 사용자 ID, IP 주소, 성공/실패 여부
- **민감 정보 제외**: 비밀번호, 토큰 등 민감 정보는 로깅 제외
- **모니터링**: 비정상적인 패턴 감지 및 알림

## 8. 알림 시스템 통합

### 8.1 네이버 클라우드 알림 서비스 활용

- **Cloud Outbound Mailer**: 이메일 인증 및 알림용
- **SENS (Simple & Easy Notification Service)**: SMS 인증 및 알림용
- **사업자 등록 기반**: 공식 비즈니스 채널로 신뢰성 향상

### 8.2 인증 시스템과 알림 시스템 통합

- **책임 분리**:
  - 인증 시스템: 인증 코드/토큰 생성 및 검증 담당
  - 알림 시스템: 실제 이메일/SMS 발송 담당
- **포트 기반 통합**: 인증 시스템에서 알림 시스템의 포트 호출
- **느슨한 결합**: 시스템 간 독립성 유지

### 8.3 본인 확인 프로세스

#### 8.3.1 회원가입 시 본인 확인

- **이메일 인증**:

  1. 인증 코드 생성 및 이메일 발송
  2. 시간 제한 내 코드 입력 및 검증
  3. 성공 시 회원가입 진행

- **SMS 인증(선택적)**:
  1. 휴대폰 번호 입력
  2. 인증 코드 SMS 발송
  3. 시간 제한 내 코드 입력 및 검증

#### 8.3.2 비밀번호 재설정 시 본인 확인

- **다중 채널 인증**:
  1. 이메일로 비밀번호 재설정 링크 발송
  2. 링크 접근 시 SMS 추가 인증(2단계 인증)
  3. 모든 단계 인증 후 비밀번호 변경 허용

#### 8.3.3 멘토 등록 시 강화된 본인 확인

- **필수 SMS 인증**:

  1. 휴대폰 번호 인증 필수화
  2. 멘토 연락처로 활용 가능(선택적)

- **신원 정보 수집**:
  1. 결제 정산을 위한 기본 신원 정보 수집
  2. 정보 암호화 및 안전한 보관

### 8.4 인증 데이터 관리

- **인증 코드 저장**: Redis 활용, 짧은 TTL 설정
- **시도 제한**: IP 및 이메일/전화번호 기준 인증 시도 횟수 제한
- **보안 조치**: 의심스러운 활동 감지 및 차단
- **가비지 컬렉션**: 만료된 인증 데이터 자동 제거

## 9. 구현 계획 및 단계

### 9.1 구현 단계

1. **기본 구조 및 도메인 모델 설계** (3-4일)

   - 도메인 모델 설계
   - 핵심 포트 정의
   - 기본 구조 설정

2. **기본 JWT 인증 구현** (5-6일)

   - JWT 서비스 구현
   - 유스케이스 구현
   - 인프라스트럭처 어댑터 구현
   - API 컨트롤러 구현

3. **Redis 통합** (3-4일)

   - Redis 연결 설정
   - 토큰 저장소 포트 구현

4. **토큰 블랙리스트 구현** (3-4일)

   - 블랙리스트 서비스 구현
   - 로그아웃 유스케이스 구현
   - JWT 가드 수정

5. **토큰 로테이션 구현** (4-5일)

   - 토큰 패밀리 개념 구현
   - 토큰 갱신 유스케이스 수정

6. **CSRF 보호 구현** (3-4일)

   - CSRF 토큰 서비스 구현
   - CSRF 가드 구현
   - 로그인 유스케이스 수정

7. **소셜 로그인 구현** (5-6일)

   - Passport 전략 구현
   - 소셜 인증 어댑터 구현
   - 소셜 로그인 유스케이스 구현
   - OAuth 콜백 컨트롤러 구현

8. **Origin 검증 및 CORS 설정** (2-3일)

   - Origin/Referer 검증 미들웨어 구현
   - CORS 정책 설정
   - 보안 헤더 구성

9. **알림 시스템 통합 및 본인 인증 구현** (5-6일)

   - 네이버 클라우드 알림 서비스 어댑터 구현
   - 인증 코드 관리 서비스 구현
   - 이메일/SMS 인증 유스케이스 구현

10. **계정 관리 기능 구현** (4-5일)

    - 아이디 찾기 기능 구현
    - 비밀번호 재설정 기능 구현
    - 프로필 관리 기능 구현

11. **Silent Refresh 구현** (4-5일)

    - 토큰 갱신 엔드포인트 구현
    - 프론트엔드 통합 지원

12. **테스트 및 최적화** (5-6일)
    - 단위 테스트 작성
    - 통합 테스트 작성
    - 성능 최적화
    - 문서화

### 9.2 개발 규칙 및 가이드라인

#### 9.2.1 코딩 컨벤션

- **네이밍 규칙**:

  - 클래스: PascalCase (예: UserService)
  - 메서드/함수: camelCase (예: findUserById)
  - 상수: UPPER_SNAKE_CASE (예: MAX_LOGIN_ATTEMPTS)
  - 변수: camelCase (예: userProfile)

- **파일 명명 규칙**:

  - 인터페이스: `*.port.ts`, `*.usecase.ts`
  - 구현체: `*.usecase.impl.ts`, `*.adapter.ts`
  - 컨트롤러: `*.controller.ts`

- **구조화 규칙**:
  - 하나의 파일에 하나의 클래스/인터페이스
  - 관련 기능별 폴더 그룹화
  - 계층별 폴더 분리

#### 9.2.2 의존성 주입 규칙

- 생성자 기반 의존성 주입 사용
- 인터페이스(포트)에 의존, 구현체에 의존하지 않음
- 환경별 설정에 따른 의존성 제공자 분리

#### 9.2.3 오류 처리 전략

- 도메인 특화 예외 클래스 사용
- 전역 예외 필터로 일관된 오류 응답 형식 제공
- 적절한 HTTP 상태 코드 매핑
- 사용자 친화적인 오류 메시지 제공

#### 9.2.4 보안 가이드라인

- 비밀번호 등 민감 정보는 로그에 포함하지 않음
- 모든 외부 입력은 유효성 검증 후 사용
- 환경별 시크릿 관리 (환경 변수 또는 시크릿 관리 서비스 활용)
- 정기적인 보안 코드 리뷰 수행

## 10. 테스트 전략

### 10.1 테스트 레벨

- **단위 테스트**: 개별 유스케이스, 도메인 서비스, 값 객체 등
- **통합 테스트**: 여러 컴포넌트 간 상호작용, 데이터베이스 연동 등
- **API 테스트**: 엔드포인트 기능 및 응답 검증
- **E2E 테스트**: 실제 사용자 흐름 시뮬레이션

### 10.2 테스트 접근법

- **FIRST 원칙** 준수:

  - Fast: 빠른 실행
  - Isolated/Independent: 독립적 실행
  - Repeatable: 반복 가능
  - Self-validating: 자체 검증
  - Timely: 적시 작성

- **Right-BICEP** 고려:

  - Right: 예상대로 작동하는지
  - Boundary: 경계 조건
  - Inverse: 역관계
  - Cross-check: 다른 수단으로 검증
  - Error: 오류 조건
  - Performance: 성능 요구사항

- **CORRECT** 테스트 조건:
  - Conformance: 값이 예상 형식을 따르는지
  - Ordering: 순서가 중요한 경우
  - Range: 범위 내의 값인지
  - Reference: 외부 의존성 확인
  - Existence: 값이 존재하는지
  - Cardinality: 정확한 값의 집합인지
  - Time: 시간 관련 이슈

### 10.3 테스트 구성 방식

- **Given-When-Then** 패턴 활용:

  - Given: 테스트 전제 조건 설정
  - When: 테스트 대상 실행
  - Then: 결과 검증

- **Describe-It-Expect** 구조:
  - describe: 테스트 그룹화
  - it: 개별 테스트 케이스
  - expect: 검증문

### 10.4 목 객체(Mocks) 및 스텁(Stubs) 전략

- 외부 의존성은 적절히 모킹하여 격리된 테스트 환경 구성
- 인프라스트럭처 계층 어댑터는 테스트용 인메모리 구현체 사용
- 필요시 테스트 더블(Test Double) 패턴 활용

이 문서는 코테피티 인증 시스템의 설계 및 구현 지침을 제공합니다. 헥사고날 아키텍처와 DDD 원칙에 따라 확장 가능하고 유지보수하기 쉬운 인증 시스템을 구축할 수 있도록 안내합니다.
